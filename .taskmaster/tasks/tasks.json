{
  "master": {
    "tasks": [
      {
        "id": 35,
        "title": "Create Basic HTML Structure and UI with Tailwind CSS",
        "description": "Develop the single-page application's foundational HTML structure. This includes setting up the main layout, a prominent drag-and-drop zone for file uploads, and placeholder elements for the future results display. Style the page using Tailwind CSS via a CDN link for rapid, minimal UI development.",
        "details": "Create an `index.html` file. Include the Tailwind CSS CDN link in the `<head>`. Structure the body with a main container. Implement a visually distinct area for drag-and-drop functionality with instructional text. Add a hidden loading spinner element and a placeholder section for the score and improvement suggestions.",
        "testStrategy": "Open the `index.html` file in a browser. Verify that the layout is centered and responsive. Confirm the drag-and-drop zone is clearly visible and styled as intended. Check that the Tailwind CSS classes are being applied correctly by inspecting elements.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Drag-and-Drop and File Validation Logic",
        "description": "Write the vanilla JavaScript to handle the drag-and-drop functionality. This includes event listeners for drag-enter, drag-leave, drag-over, and drop. Implement client-side validation to ensure only a single PDF file is uploaded and that its size does not exceed the 5MB limit.",
        "details": "In a `<script>` tag or a separate `app.js` file, add event listeners to the drag-and-drop zone. On drop, prevent the default browser action. Access the dropped file(s) from the `dataTransfer` object. Validate the file count (must be 1), file type (`application/pdf`), and file size (`file.size < 5 * 1024 * 1024`). Display an alert or message for invalid files. On valid file drop, show the processing indicator.",
        "testStrategy": "Test by dragging and dropping a valid PDF file (<5MB). Verify the processing indicator appears. Test dropping multiple files, a non-PDF file, and a PDF file larger than 5MB; ensure appropriate error feedback is shown and the file is rejected.",
        "priority": "high",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Integrate PDF.js for Client-Side Text Extraction",
        "description": "Integrate the PDF.js library to process the uploaded PDF file entirely on the client side. The goal is to extract the raw text content from the PDF for subsequent analysis.",
        "details": "Include the PDF.js library via its CDN. When a valid PDF is received from the file handler, use the PDF.js API to load the document. Iterate through each page of the PDF, extract the text content using `page.getTextContent()`, and concatenate the text from all pages into a single string. Implement error handling for corrupted or password-protected PDFs.",
        "testStrategy": "Use several sample PDF resumes. After dropping a PDF, log the extracted text to the browser console. Verify that the text is readable and accurately reflects the content of the PDF. Test with a multi-page PDF. Test with a known corrupted or protected PDF to ensure error handling works.",
        "priority": "high",
        "dependencies": [
          36
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Develop Initial Rule-Based ATS Scoring Algorithm",
        "description": "Create the first version of the ATS scoring engine based on hardcoded, rule-based checks. This version will analyze the raw extracted text for format compatibility and basic content structure without relying on AI.",
        "details": "Create a JavaScript function `calculateInitialScore(text)`. Implement checks based on the PRD's criteria: \n- **Format Compatibility (25%):** Scan for non-standard fonts (if possible without full rendering), check for keywords like 'header'/'footer', and assess spacing patterns. \n- **Content Structure (30%):** Use regex to find standard section headers ('Experience', 'Education', 'Skills'), check for email/phone patterns, and validate date formats (MM/YYYY). \n- **Readability & Parsing (20%):** Calculate a simple score based on text length and bullet point usage (checking for '*' or '-' at the start of lines).",
        "testStrategy": "Create test strings simulating extracted resume text. Pass these strings to the scoring function and assert that the calculated scores for each category are as expected. Test with a 'perfect' resume string and a 'poor' one to check the scoring range.",
        "priority": "medium",
        "dependencies": [
          37
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Integrate Google Gemini API for Content Semanticization",
        "description": "Connect to the Google Gemini API to perform advanced NLP analysis on the extracted resume text. The primary goal is to use AI to intelligently parse and semanticize the resume content.",
        "details": "Create a function to make a client-side API call to the Gemini endpoint. Securely manage the API key. Construct a detailed prompt that instructs the model to identify and extract key resume sections (Contact, Summary, Experience, Education, Skills) and return the data in a structured JSON format. The prompt should also ask for keyword extraction and context analysis.",
        "testStrategy": "Using a sample of extracted resume text, call the Gemini API function. Log the response to the console. Verify that the API returns a well-structured JSON object containing the correctly identified resume sections and relevant keywords. Check for proper error handling if the API call fails.",
        "priority": "high",
        "dependencies": [
          37
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Enhance Scoring Engine with AI-Powered Analysis",
        "description": "Refine the ATS scoring engine by incorporating the structured data received from the Gemini API. This will improve the accuracy of the 'Content Structure' and 'Keyword Optimization' scores.",
        "details": "Modify the scoring function to accept the Gemini API output. \n- **Content Structure (30%):** Use the AI-identified sections to verify completeness (e.g., are Experience and Education present?). Check for reverse chronological order within the structured 'Experience' data. \n- **Keyword Optimization (25%):** Analyze the keywords extracted by the AI. Score based on the presence of industry-relevant terms, action verbs, and quantifiable achievements. \n- Combine these AI-driven scores with the initial rule-based scores to produce a final, weighted total.",
        "testStrategy": "Create mock Gemini API response objects. Pass these, along with raw text, to the enhanced scoring engine. Verify that the presence or absence of key sections and keywords in the mock response correctly influences the final score. Check that the weighting (e.g., Keywords 25%, Structure 30%) is applied correctly.",
        "priority": "medium",
        "dependencies": [
          38,
          39
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement Dynamic Results Display UI",
        "description": "Develop the UI component to display the final ATS score and the detailed breakdown. The display should be clean, simple, and provide immediate, easy-to-understand feedback.",
        "details": "Create a JavaScript function to render the results. This function will take the final score object as input. Display the overall score (0-100) prominently. Implement the color-coding logic (Red: 0-60, Yellow: 61-80, Green: 81-100) for the score display. Show the breakdown of scores by category (Format Compatibility, Content Structure, Keyword Optimization, Readability). Unhide the results section and hide the loading spinner upon completion.",
        "testStrategy": "Manually call the render function with sample score objects representing low, medium, and high scores. Verify that the overall score is displayed correctly and that the background color changes according to the rules. Check that the category breakdown is visible and accurate.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Generate and Display Actionable Improvement Suggestions",
        "description": "Based on the scoring analysis, generate a short list of the most critical improvement suggestions and display them to the user.",
        "details": "Create a function that analyzes the score breakdown. If a category score is low, generate a corresponding suggestion. For example: \n- Low 'Format Compatibility' score: 'Avoid using tables, columns, or graphics. Stick to standard fonts like Arial or Calibri.' \n- Low 'Keyword Optimization': 'Include more industry-specific keywords and action verbs relevant to the target job.' \n- Missing 'Summary' section: 'Add a professional summary at the top of your resume.' \nDisplay these suggestions as a simple bulleted list below the score breakdown.",
        "testStrategy": "Provide the suggestion generation function with various low-score scenarios. Verify that the generated suggestions are relevant to the low-scoring category. Ensure that no more than 3-4 key suggestions are displayed to avoid overwhelming the user. Check that the suggestions are displayed correctly in the UI.",
        "priority": "low",
        "dependencies": [
          41
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Project Scaffolding and Initial Setup",
        "description": "Create the basic file structure for the vanilla JavaScript application and include all necessary CDN dependencies.",
        "details": "Create `index.html`, `script.js`, and `style.css`. In `index.html`, add the boilerplate HTML and link the CSS and JS files. Include the CDN links for Tailwind CSS and the PDF.js library as specified in the PRD.",
        "testStrategy": "Open `index.html` in a browser. Verify that the page loads without errors, Tailwind CSS utility classes work (e.g., changing a background color), and the `pdfjsLib` object is available in the browser's developer console.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement Drag-and-Drop File Upload Zone",
        "description": "Develop the UI and logic for a drag-and-drop area to accept a single PDF file.",
        "details": "Using HTML and JavaScript, create a visually distinct drop zone. Implement event listeners for `dragover`, `dragleave`, and `drop`. Add validation to ensure the dropped file is a single PDF and does not exceed the 5MB size limit. Provide visual feedback to the user (e.g., changing border style on hover, showing an error message for invalid files).",
        "testStrategy": "Drag a valid PDF file onto the zone and verify it is accepted. Drag a non-PDF file (e.g., .jpg, .txt) and verify it is rejected with a message. Drag a PDF file larger than 5MB and verify rejection. Drag multiple files and verify rejection.",
        "priority": "high",
        "dependencies": [
          43
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Integrate PDF.js for Client-Side Text Extraction",
        "description": "Use the PDF.js library to read the uploaded PDF file and extract its full text content.",
        "details": "When a valid PDF is dropped, use the `pdfjsLib` to load the file data. Iterate through each page of the PDF, get the text content, and concatenate it into a single string. Implement a loading indicator that is displayed while the PDF is being processed. For now, log the extracted text to the console to verify success. Include basic error handling for corrupted or password-protected PDFs.",
        "testStrategy": "Upload a sample resume in PDF format. Verify the loading indicator appears. Check the developer console to ensure the full text content of the resume is extracted and logged correctly. Test with a multi-page PDF.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Develop Baseline ATS Scoring Algorithm (Non-AI)",
        "description": "Create the initial version of the ATS scoring engine based on hardcoded rules for format, structure, and readability.",
        "details": "Create a JavaScript function `calculateBaseScore(text)`. This function will implement scoring logic for 'Format Compatibility' and 'Content Structure'. Use regex and string matching to check for: standard section headers (Experience, Education, Skills), presence of contact info (email, phone patterns), reverse chronological order (heuristic check on dates), and use of bullet points. Assign weights to each criterion as per the PRD (Format: 25%, Structure: 25%).",
        "testStrategy": "Pass text from various sample resumes to the function. Manually verify that resumes with clear sections and contact info score higher than poorly formatted ones. Use unit tests to check specific rules, like email pattern detection.",
        "priority": "high",
        "dependencies": [
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement Gemini API Integration for Content Semanticization",
        "description": "Set up the client-side API call to Google Gemini to analyze the extracted resume text.",
        "details": "Create a function to send the extracted text to the Gemini API. Construct a structured prompt that asks the model to identify and extract resume sections (Contact, Summary, Experience, etc.), skills, and keywords, returning the output in a structured JSON format. Securely manage the API key on the client-side for this rapid development phase (e.g., storing in a non-committed config file). Handle API call states (loading, success, error).",
        "testStrategy": "Using a sample extracted resume text, call the Gemini API function. Verify that the API returns a well-formed JSON object containing the expected semantic sections. Check that API errors (e.g., invalid key, network issue) are handled gracefully.",
        "priority": "high",
        "dependencies": [
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Enhance Scoring Algorithm with AI Analysis",
        "description": "Integrate the Gemini API response to score the remaining criteria: Keyword Optimization and Readability.",
        "details": "Update the scoring engine to use the structured JSON from the Gemini API. Implement logic for 'Keyword Optimization' (30%) by analyzing the extracted skills and keywords against a predefined list of industry terms. Implement 'Readability & Parsing' (20%) by assessing the completeness of sections returned by the AI and checking for quantifiable achievements. Combine all four scores into a final 0-100 ATS score.",
        "testStrategy": "Process a resume and mock the Gemini API response. Verify the keyword and readability scores are calculated correctly. Test with another resume, provide a real Gemini response, and check that the final combined score is calculated as expected.",
        "priority": "medium",
        "dependencies": [
          46,
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Create Results Display UI",
        "description": "Develop the UI components to display the final ATS score, color-coded rating, and detailed breakdown.",
        "details": "Create a new section in `index.html` that is initially hidden. After processing, display this section with the final score (0-100). Implement the color-coding logic (Red: 0-60, Yellow: 61-80, Green: 81-100). Add sub-sections to show the individual scores for the four categories: Format Compatibility, Content Structure, Keyword Optimization, and Readability.",
        "testStrategy": "Manually trigger the results display with sample scores. Verify a score of 55 shows a red background, 75 shows yellow, and 90 shows green. Ensure all four category scores are displayed correctly.",
        "priority": "high",
        "dependencies": [
          48
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Generate and Display Actionable Improvement Suggestions",
        "description": "Based on the scoring results, generate and display specific, helpful tips for the user to improve their resume.",
        "details": "Create a logic module that takes the detailed scoring breakdown as input. For each category with a low score, select a relevant improvement suggestion from a predefined list. For example, if 'Content Structure' is low, suggest 'Add a Professional Summary section'. If 'Keyword Optimization' is low, suggest 'Include more industry-specific keywords related to the target job'. Display these suggestions in a clear list below the score breakdown.",
        "testStrategy": "Provide a low score for the 'Format Compatibility' category and verify the UI displays a suggestion related to formatting (e.g., 'Use standard fonts like Arial or Calibri'). Test for each of the four categories.",
        "priority": "medium",
        "dependencies": [
          49
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "ML: Generate Synthetic Salary Training Data",
        "description": "Create a Python script to generate a synthetic dataset for training the salary prediction model.",
        "details": "Following the PRD, write a script using libraries like pandas and numpy to generate a CSV file. The data should include features like 'years_of_experience', 'role', 'location', 'ats_score', 'skills_count', and a target variable 'salary'. Implement realistic distributions and correlations, such as salary increasing with experience and varying by role and location.",
        "testStrategy": "Run the script and inspect the output CSV. Use data visualization (e.g., matplotlib) to plot distributions and correlations (e.g., salary vs. experience) to ensure they appear realistic and align with the PRD's specifications.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "ML: Train and Export Baseline Salary Prediction Model",
        "description": "Use the synthetic data to train a machine learning model and export it for inference.",
        "details": "Using Python with scikit-learn or XGBoost, load the synthetic dataset from the previous task. Preprocess the data (e.g., one-hot encode categorical features). Train a regression model (e.g., GradientBoostingRegressor) to predict 'salary'. Evaluate the model's performance using MAE and R-squared metrics. Save the trained model to a file (e.g., using pickle or joblib).",
        "testStrategy": "Verify that the training script runs to completion. Check the console output for performance metrics (e.g., R-squared > 0.85). Ensure a model file is created in the specified directory.",
        "priority": "low",
        "dependencies": [
          51
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "ML: Implement Client-Side Feature Extraction and Prediction Logic",
        "description": "Extract ML features from the resume analysis and implement a placeholder prediction function.",
        "details": "In `script.js`, create a function `predictSalary(resumeData)`. This function will extract features required by the ML model from the Gemini API response and the base ATS score (e.g., years of experience, number of skills, ATS score). Since deploying a Python model for client-side JS is complex for this initial phase, implement a simplified prediction logic using a hardcoded rule-based model (e.g., if-else statements based on experience) that mimics the trained model's behavior as a placeholder.",
        "testStrategy": "Pass sample resume analysis data to the `predictSalary` function. Verify that it extracts the correct features and returns a salary estimate based on the hardcoded rules (e.g., a resume with 5 years experience returns a higher salary than one with 1 year).",
        "priority": "low",
        "dependencies": [
          47,
          52
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "ML: Integrate Salary Prediction into UI",
        "description": "Create UI components to display the salary prediction results to the user.",
        "details": "In the results section of `index.html`, add new elements to display the salary prediction. This should include the primary salary estimate, an expected range (min-max), and a simple market comparison. Call the `predictSalary` function after the ATS score is calculated and populate these new UI elements with the returned data.",
        "testStrategy": "Process a full resume. Verify that after the ATS score is displayed, the salary prediction section also appears and is populated with realistic-looking data from the placeholder function. Check that the UI handles cases where a prediction cannot be made.",
        "priority": "low",
        "dependencies": [
          49,
          53
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Create Configuration for OTS Salary Bands and Growth Factors",
        "description": "Establish the foundational configuration files for OTS-specific salary bands and growth factors as specified in the PRD. This will serve as the single source of truth for the calculation engine.",
        "details": "Create a new directory `src/config`. Inside, create a file `salaryConfig.js`. This file should export an object containing `experienceBands` and `growthFactors` based on the data models in the PRD. For example: `experienceBands: [{ range: '0-2', baseSalary: 400000 }, ...]`, `growthFactors: { yearly: 1.12, roleTransition: 1.25 }`.",
        "testStrategy": "Create a unit test to import the configuration and assert that the data structure is correct and values match the PRD. Verify that the exported object is not mutable.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Implement Core Salary Calculation Service",
        "description": "Develop a service module that calculates the base salary for a candidate based on their years of experience and the configured salary bands.",
        "details": "Create a new file `src/services/salaryService.js`. This service should have a primary function, e.g., `calculateBaseSalary({ yearsOfExperience })`, that imports the configuration from `salaryConfig.js` (Task 55). The function should determine the correct salary band for the given experience and return the corresponding base salary.",
        "testStrategy": "Write unit tests for the `calculateBaseSalary` function. Test various experience levels, including edge cases like 0 years, 2 years (boundary), and values outside the defined bands.",
        "priority": "high",
        "dependencies": [
          55
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "Create Initial 'SalaryPredicted' UI Component",
        "description": "Develop a new React component to display the predicted salary information. Initially, it will show the estimated base salary and experience level.",
        "details": "Create a new component file `src/components/SalaryDisplay.js`. This component should accept props like `estimatedSalary`, `experienceLevel`, etc. Style it using a clean, card-based layout as per the PRD. Integrate this new component into the main results view (likely `src/components/ScoreDisplay.js`), positioning it below the overall score.",
        "testStrategy": "Use Storybook or a similar tool to visually test the component with various props. Ensure it renders correctly with and without data. Check responsiveness on different screen sizes.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 58,
        "title": "Integrate Salary Service with Resume Analysis Flow",
        "description": "Connect the salary calculation logic to the main application flow, so that the salary is predicted automatically after a resume is analyzed.",
        "details": "In the component that handles the resume analysis result (likely `src/App.js`), after receiving the analysis data (which includes years of experience), call the `calculateBaseSalary` function from the `salaryService`. Pass the calculated salary and other relevant data as props to the `SalaryDisplay` component.",
        "testStrategy": "Perform an end-to-end test. Upload a resume, wait for the analysis to complete, and verify that the `SalaryDisplay` component appears with the correctly calculated base salary based on the parsed experience.",
        "priority": "high",
        "dependencies": [
          56,
          57
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 59,
        "title": "Establish Premium College Database and Configuration",
        "description": "Create a configuration file to store the list of premium colleges, their tiers, weightage, and the decay factor.",
        "details": "Create a new file `src/config/collegeConfig.js`. This file will export an object containing `collegeTiers` (e.g., `{ tier: 'premium', weight: 1.3 }`) and a `decayFactor` (e.g., 0.95). It should also include a list of colleges mapped to their respective tiers.",
        "testStrategy": "Write a unit test to ensure the configuration file can be imported and contains the expected data structures (`collegeTiers`, `decayFactor`, college list).",
        "priority": "medium",
        "dependencies": [
          55
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 60,
        "title": "Enhance Salary Service with Premium College Weightage",
        "description": "Update the salary calculation service to factor in the premium college weightage, including the decay of the premium over time.",
        "details": "Modify `src/services/salaryService.js`. The main calculation function should now accept college information and graduation year. It will use `collegeConfig.js` to find the appropriate weight. The final weight should be calculated as `baseWeight * (decayFactor ^ yearsSinceGraduation)`. Apply this final weight to the base salary.",
        "testStrategy": "Update unit tests for the salary service. Add test cases for candidates from premium and standard colleges, and verify the weight is applied correctly. Test the decay factor by simulating different numbers of years post-graduation.",
        "priority": "medium",
        "dependencies": [
          56,
          59
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 61,
        "title": "Update Salary UI to Display College Tier Impact",
        "description": "Enhance the `SalaryDisplay` component to show the impact of the candidate's college tier on their estimated salary.",
        "details": "Add a new section to the `SalaryDisplay` component. It should conditionally render if a college premium is applied. Display the identified college tier (e.g., 'Tier 1 College'), the applied weightage, and the resulting impact on the base salary. For example: '+ â‚¹80,000 (Premium College Bonus)'.",
        "testStrategy": "Update the component's visual tests (e.g., Storybook) to include states where a college premium is applied and where it is not. Verify the information is clear and accurately reflects the calculations.",
        "priority": "medium",
        "dependencies": [
          57,
          60
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 62,
        "title": "Implement Growth Projection Logic in Salary Service",
        "description": "Extend the salary service to calculate and return potential salary growth based on year-on-year and role transition factors.",
        "details": "Add a new function to `src/services/salaryService.js`, e.g., `calculateGrowthProjections`. This function will take the calculated base salary and experience level as input. It will use the `growthFactors` from `salaryConfig.js` to project salary for the next 1-3 years and estimate the salary upon a potential role transition.",
        "testStrategy": "Write new unit tests for the `calculateGrowthProjections` function. Verify that the annual growth and role transition multipliers are applied correctly to the base salary.",
        "priority": "medium",
        "dependencies": [
          56
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 63,
        "title": "Add 'Potential Growth Path' Visualization to UI",
        "description": "Enhance the `SalaryDisplay` component to visually represent the candidate's potential salary growth path.",
        "details": "Add a 'Potential Growth Path' section to the `SalaryDisplay` component. Use the data from the `calculateGrowthProjections` service (Task 62). Display the projected salary for the next year using the annual growth factor. You can use simple text, a small chart, or progress indicators to show this information clearly.",
        "testStrategy": "Visually test the component to ensure the growth projections are displayed in an easy-to-understand format. Test with different base salaries to ensure the projections update accordingly.",
        "priority": "low",
        "dependencies": [
          57,
          62
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 64,
        "title": "Refine Experience Parsing and Validation Logic",
        "description": "Improve the accuracy of experience parsing from resumes to handle various formats and edge cases, providing a more reliable input for the salary engine.",
        "details": "Locate the existing resume parsing logic. Enhance it to handle different text formats for years of experience (e.g., '3 yrs', '4.5 years', '2 years 6 months'). Add validation to ensure the parsed value is a number. Consider adding a manual override field in the UI as a mitigation strategy if parsing fails.",
        "testStrategy": "Create a test suite with a wide variety of resume snippets containing different experience formats. Assert that the parser extracts the correct numerical value in each case. Test with resumes where experience is not mentioned to ensure graceful failure.",
        "priority": "low",
        "dependencies": [
          58
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 65,
        "title": "Create OTS-Specific Synthetic Salary Calculation Database",
        "description": "Develop a comprehensive, standalone configuration file containing synthetic data for OTS-specific salary calculations, including a premium college catalog, detailed salary bands, role-based multipliers, and location-based adjustments.",
        "details": "Create a new file at `src/config/otsSalaryDatabase.js`. This file will export a single, frozen object containing all configuration data specified in PRD2.txt, and must be kept separate from general ML training configurations. The structure should be as follows:\n1. `premiumColleges`: An array of objects, where each object contains `name` (string), `tier` (string, e.g., 'tier1'), and `weight` (number).\n2. `salaryBands`: An array of objects defining OTS job levels. Each object should include `level` (string, e.g., 'L3'), `experienceYears` (string, e.g., '2-4'), `baseMin` (number), and `baseMax` (number).\n3. `roleMultipliers`: A key-value object mapping role titles (string) to a numerical multiplier. Example: `{ \"Software Engineer\": 1.0, \"Data Scientist\": 1.1 }`.\n4. `locationAdjustments`: A key-value object mapping geographic locations (string) to a cost-of-living multiplier. Example: `{ \"SF Bay Area\": 1.25, \"Austin, TX\": 1.05 }`.\nAll data points must be sourced directly from PRD2.txt.",
        "testStrategy": "Create a new unit test file `otsSalaryDatabase.test.js`. The tests should:\n1. Verify that the `otsSalaryDatabase.js` module can be imported without errors.\n2. Assert that the main exported object is frozen using `Object.isFrozen()` to prevent runtime modifications.\n3. Validate the data schema for each key (`premiumColleges`, `salaryBands`, `roleMultipliers`, `locationAdjustments`), ensuring they are the correct type (array/object) and their contents have the specified properties and types.\n4. Spot-check at least two specific data points from each section against the values in PRD2.txt to ensure accuracy (e.g., check the weight for a specific college, the base salary for a specific level, and the multiplier for a specific role and location).",
        "status": "pending",
        "dependencies": [
          55,
          59
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 66,
        "title": "Update Application Gradient to Modern, Accessible Color Scheme",
        "description": "Replace the current purple/blue gradient with a modern, accessible color combination to improve readability and visual appeal, aligning with 2024 UI design trends.",
        "details": "Locate the global CSS or theme configuration file (e.g., `src/styles/variables.scss` or a theme object in JS) where the primary application gradient is defined. Replace the existing purple/blue color codes with a new gradient scheme, such as a deep space blue (#0D1B2A) to a vibrant cyan (#1E90FF). Ensure all CSS variables and classes using the old gradient (e.g., `--gradient-primary`, `.app-background`) are updated. The new theme should maintain a premium aesthetic while significantly improving the contrast ratio for text and foreground elements.",
        "testStrategy": "1. Conduct a full visual regression test using Storybook or Percy to compare screenshots of key components before and after the change. 2. Manually review all application pages to ensure the new gradient is applied consistently and without visual artifacts. 3. Use a browser-based accessibility tool (e.g., Lighthouse, WAVE) to perform a contrast audit on all text and interactive elements that overlay the new gradient, ensuring they meet WCAG AA standards. 4. Verify the gradient renders correctly across the latest versions of Chrome, Firefox, and Safari.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-01T14:39:06.911Z",
      "updated": "2025-09-04T09:34:59.993Z",
      "description": "Tasks for master context"
    }
  }
}